package scripts.game{	import flash.display.*;	import flash.events.*;	import flash.display.Stage;	import flash.text.TextField;	import flash.events.MouseEvent;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.geom.Matrix;	import flash.geom.Rectangle;	import flash.geom.Point;	import flash.net.URLRequest;	import flash.net.URLLoader;	import flash.external.ExternalInterface;	import flash.system.System;	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.utils.getDefinitionByName;	import flash.utils.getQualifiedClassName;	import flash.filters.*;	import flash.geom.ColorTransform;	import scripts.game.sceneObjects.waypoint;	import scripts.game.sceneObjects.hearthFireplace;	import scripts.game.sound.sceneSoundEmitter;	public class sceneSideScroll extends MovieClip {		//scrolling		private var pRoot:Object = null;		private var pReadyState:int = 0;		private var pSceneName:String = "";		private var pLoader:Loader = new Loader  ;		public var pSwfObj:Object = null;		private var pSwfTarget;		public var pScrollX:Number = 0;		public var pScrollY:Number = 0;		//dimentions		private var pScreenW = 1000;		private var pScreenH = 500;		private var pScreenW2 = Math.round((pScreenW / 2));		private var pScreenH2 = Math.round((pScreenH / 2));		private var pRect:Rectangle = new Rectangle  ;		private var pPnt:Point = new Point  ;		public var pMapWidth:int = pScreenW;		public var pMapHeight:int = pScreenH;		public var pMapLimX:int = pScreenW;		public var pMapLimY:int = pScreenH;		public var pScreenRect:Rectangle = new Rectangle(0,0,pScreenW,pScreenH);		public var pCollisionMap:Array = [];		private var pShowCollisionMap:Boolean = false;		private var pBlurFilter:BlurFilter = new BlurFilter  ;		private var pClrTrans:ColorTransform = new ColorTransform  ;		//interactive objects and animated objects		public var pL3Interactive:Object = null;		public var pL2Interactive:Object = null;		public var pAvatarLayerArray:Array = null;		//bitmap data objects		private var gSourceBMD1:BitmapData = null;		private var gSourceBMD2:BitmapData = null;		private var gSourceBMD3:BitmapData = null;		public var gCollisionBMD:BitmapData = null;		private var gVignetteBMD:BitmapData = null;		public var gDestinBMD1:BitmapData = null;		private var gDestinBM1:Bitmap = null;		public var gDestinBMD2:BitmapData = null;		private var gDestinBM2:Bitmap = null;		//scene settings		public var pSceneAttributes:Object = {};		private var pReflection:Array = null;		private var pVectorScene:Boolean = false;		private var pAvatarPopup:Object = null;		private var pAvatarPopupActive:Boolean = false;		//------------------------------------------------------------------------------------------------------------------------		//------------------------------------------------------------------------------------------------------------------------		// init		//------------------------------------------------------------------------------------------------------------------------		//------------------------------------------------------------------------------------------------------------------------		public function sceneSideScroll():void {		}		//		public function init(vRoot:Object,nme:String):void {			pSceneName = nme;			pRoot = vRoot;			this.addEventListener(Event.ENTER_FRAME,enterframe);			pRoot.stage.addEventListener(MouseEvent.MOUSE_DOWN,mousedown);			traceOut(("init for " + nme));			loadScene();			var stats:Object = new Stats  ;			stats.x = 935;			pRoot.addChild(stats);			createAvatarPopup();		}		//		private function loadScene():void {			var assetPath:String = "scenes/scene_" + pSceneName + ".swf";			pLoader = new Loader  ;			pLoader.contentLoaderInfo.addEventListener(Event.COMPLETE,loadSceneDone);			pLoader.load(new URLRequest(assetPath));		}		//		private function loadSceneDone(e:Event):void {			traceOut("loadSceneDone");			pSwfTarget = e.target;			pSwfObj = pLoader.content as MovieClip;			//this.addChild(pSwfObj);			pLoader = null;			retrieveSceneData();		}		//		private function retrieveSceneData():void {			pSwfObj.init(pRoot);			pSceneAttributes = pSwfObj.pSceneAttributes;			pReflectionArray = pSceneAttributes.pReflectionArray;			pAvatarLayerArray = pSceneAttributes.pAvatarLayerArray;			pMapWidth = pSwfObj.L3.width;			pMapHeight = pSwfObj.L3.height;			if ((pMapHeight < pScreenH)) {				pMapHeight = pScreenH;			}			pMapLimX = pMapWidth - pScreenW - 20;			pMapLimY = pMapHeight - pScreenH - 20;			if (pSceneAttributes.pVectorScene) {				pVectorScene = true;			}			traceOut(("retrieveSceneData = " + [pMapWidth,pMapHeight]));			setMoonPhaseA();			vectorLayersToBitmap();			createDestinationScreen();			loadInteractiveLayers();			pRoot.sideScrollSceneReady();		}		//		private function setMoonPhaseA():void {			if (pSceneAttributes.pMoonsActive) {				var L1:Object = pSwfObj.L1;				setMoonPhaseB(L1.rMoon,L1.rMoonGlow,pSwfObj.L3.rOverlay,pRoot.gRmoonPhase);				setMoonPhaseB(L1.gMoon,L1.gMoonGlow,pSwfObj.L3.gOverlay,pRoot.gGmoonPhase);				setMoonPhaseB(L1.bMoon,L1.bMoonGlow,pSwfObj.L3.bOverlay,pRoot.gBmoonPhase);			}		}		//		private function setMoonPhaseB(vMoon:Object,vGlow:Object,vSky:Object,vPhase:int):void {			vHorizonY = vMoon.y;			var lx:int = vPhase * 10;			var deg:int = (vPhase * 3.6);			var ly:int = vHorizonY + (.6 * (vHorizonY * Math.cos((deg * 0.0174))));			var dx:int = 500 - lx;			var dy:int = 500 - ly;			var rot:Number = 0 + Math.atan2(dy,dx) / .0174;			if ((rot > 90)) {				rot = rot + 180;			}			vMoon.x = lx;			vMoon.y = ly;			vGlow.x = lx;			vGlow.y = ly;			traceOut(("moon loc = " + [vMoon.name,vPhase,lx,ly]));			vMoon.rotation = rot;			var frm:int = Math.round(vPhase);			vMoon.gotoAndStop(frm);			vGlow.gotoAndStop(frm);			//			var n:Number;			if ((vPhase < 50)) {				n = vPhase / 50;			} else {				n = 1 - (vPhase - 50) / 50;			}			if (vSky) {				vSky.alpha = n / 2;			}		}		//------------------------------------------------------------------------------------------------------------------------		//------------------------------------------------------------------------------------------------------------------------		// interactive layers		//------------------------------------------------------------------------------------------------------------------------		//------------------------------------------------------------------------------------------------------------------------		private function loadInteractiveLayers():void {			traceOut("loadInteractiveLayers");			pL2Interactive = {};			pL3Interactive = {};			if ("L3_interactive" in pSwfObj) {				pL3Interactive = pSwfObj.L3_interactive;				pRoot.addChild(pL3Interactive);				var i:int = 0;				var mc:Object = null;				for (i= 0; i < pL3Interactive.numChildren; i++) {					mc = pL3Interactive.getChildAt(i);					if ("init" in mc) {						mc.init(pRoot,this,pL3Interactive,pSwfTarget);					}				}			}			if ("L2_interactive" in pSwfObj) {				pL2Interactive = pSwfObj.L2_interactive;				pRoot.addChild(pL2Interactive);				for (i= 0; i < pL2Interactive.numChildren; i++) {					mc = pL2Interactive.getChildAt(i);					if ("init" in mc) {						mc.init(pRoot, this, pL2Interactive, pSwfTarget);					}				}			}			if (pVectorScene) {				var n:int = pRoot.numChildren;				pRoot.addChildAt(gDestinBM2, n);				gDestinBM2.x = 0;			}		}		//		private function L2ObjectsEnterFrame():void {			for (var i = 0; i < pL2Interactive.numChildren; i++) {				var mc:Object = pL2Interactive.getChildAt(i);				mc.enterframe();			}		}		//		private function L3ObjectsEnterFrame():void {			for (var i = 0; i < pL3Interactive.numChildren; i++) {				var mc:Object = pL3Interactive.getChildAt(i);				mc.enterframe();			}		}		//------------------------------------------------------------------------------------------------------------------------		//------------------------------------------------------------------------------------------------------------------------		// Blitting		//------------------------------------------------------------------------------------------------------------------------		//------------------------------------------------------------------------------------------------------------------------		private function vectorLayersToBitmap():void {			traceOut("convertVectorLayerToBitmap");			var blankScene:Class = pRoot.pBlankScene;			//var BlankScene:Object = pRoot. 			gSourceBMD1 = new BitmapData(pScreenW,pScreenH,false);			gSourceBMD2 = new blankScene(pSwfObj.L2.width,pSwfObj.L2.height);			gSourceBMD3 = new blankScene(pSwfObj.L3.width,pSwfObj.L3.height);			gSourceBMD4 = new blankScene(pSwfObj.L4.width,pSwfObj.L4.height);			gVignetteBMD = new blankScene(pScreenW,pScreenH);			gCollisionBMD = new blankScene(pSwfObj.LC.width,pSwfObj.LC.height);			gSourceBMD1.draw(pSwfObj.L1);			gSourceBMD2.draw(pSwfObj.L2);			gSourceBMD3.draw(pSwfObj.L3);			gSourceBMD4.draw(pSwfObj.L4);			gVignetteBMD.draw(pSwfObj.LV);			gCollisionBMD.draw(pSwfObj.LC);			//pShowCollisionMap = true;			if (pShowCollisionMap) {				var adjustAlpha:ColorTransform = new ColorTransform  ;				adjustAlpha.alphaMultiplier = 0.2;				var rect:Rectangle = new Rectangle(0,0,pSwfObj.width,pSwfObj.height);				gCollisionBMD.colorTransform(rect,adjustAlpha);				gSourceBMD3.draw(gCollisionBMD);			}		}		//		private function createDestinationScreen():void {			traceOut("createDestinationScreen");			gDestinBMD1 = new BitmapData(pScreenW,pScreenH,false);			gDestinBM1 = new Bitmap(gDestinBMD1);			pRoot.addChildAt(gDestinBM1,0);			if (pVectorScene) {				//just paste the background once				pRect = new Rectangle(0,0,pScreenW,pScreenH);				gDestinBMD1.copyPixels(gSourceBMD1,pRect,pPnt,null,null,false);				//create additional bitmap on top of vector scene for avatars to be pasted in;				gDestinBMD2 = new BitmapData(pScreenW,pScreenH,true,0x00000000);				gDestinBM2 = new Bitmap(gDestinBMD2);			}			pReadyState = 1;		}		//--------------------------------------------------------------------------		//--------------------------------------------------------------------------		// enterframe and blitting		//--------------------------------------------------------------------------		//--------------------------------------------------------------------------		private function enterframe(event:Event):void {			switch (pReadyState) {				case -1 :				case 0 :					return;					break;				case 1 :					blitLayers();					checkAvatarRollOut();					break;			}		}		//		public function scrollMap(vx:int,vy:int):void {			var lx1:int = pScrollX;			var ly1:int = pScrollY;			var lx2:int = vx - pScreenW2;			var ly2:int = vy - pScreenH2;			var distX:int = lx2 - lx1;			var distY:int = ly2 - ly1;			if (Math.abs(distX) > 20 || Math.abs(distY) > 20) {				if ((pMapWidth > 1050)) {					pScrollX = pScrollX + distX / 20;				}				if ((pMapHeight > 550)) {					pScrollY = pScrollY + distY / 20;				}				limitScroll();			}			//move the interactive layer. The other layers are blitted on enterframe			pL3Interactive.x = 0 - pScrollX;			pL3Interactive.y = 0 - pScrollY;		}		//		private function limitScroll():void {			if ((pScrollX < 10)) {				pScrollX = 10;			}			if ((pScrollX > pMapLimX)) {				pScrollX = pMapLimX;			}			if ((pMapHeight < 520)) {				pScrollY = 0;			} else {				if ((pScrollY < 0)) {					pScrollY = 0;				}				if ((pScrollY > pMapLimY)) {					pScrollY = pMapLimY;				}			}		}		//		public function forceScrollJump(vx:int):void {			trace("forceScrollJump");			pScrollX = vx;			scrollMap(pScrollX, pScrollY);		}		//		private function blitLayers():void {			//traceOut ("blitLayers");			if ((pMapHeight < (pScreenH + 100))) {				pScrollY = 0;			}			var lx:int = pScrollX;			var ly:int = pScrollY;			pPnt.x = 0;			pPnt.y = 0;			//Scroll Foreground and background some ratio of sceen scroll, for parallax effect			if (pVectorScene) {				gDestinBMD2.fillRect(gDestinBMD2.rect, 0);				blitAllAvatars(true);				blitAllAvatars(false);				L3ObjectsEnterFrame();			} else {				// draw background				pRect = new Rectangle(0,0,pScreenW,pScreenH);				gDestinBMD1.copyPixels(gSourceBMD1,pRect,pPnt,null,null,false);				//draw midground;				lx = Math.round((pScrollX * .3));				if (pSceneAttributes.pRetroParralax == true) {					lx = pScreenW - lx;				}				ly = 15;				ly = 0;				pRect = new Rectangle(lx,ly,pScreenW + lx,pScreenH + ly);				gDestinBMD1.copyPixels(gSourceBMD2,pRect,pPnt,null,null,true);				//draw all avatars, motes, etc;				L2ObjectsEnterFrame();				blitAllAvatars(false);				//draw game layer;				lx = Math.round(pScrollX);				ly = Math.round(pScrollY);				pRect = new Rectangle(lx,ly,pScreenW + lx,pScreenH + ly);				gDestinBMD1.copyPixels(gSourceBMD3,pRect,pPnt,null,null,true);				//draw avatars and any interactive objects above L3;				blitAllAvatars(true);				L3ObjectsEnterFrame();				//do reflections				if ((pReflectionArray != null)) {					var reflectY1:int = pReflectionArray[0];					var reflectY2:int = pReflectionArray[1];					var reflectY3:int = pReflectionArray[2];					var reflectHeight:int = reflectY2 - reflectY1;					var vAlpha:Number = pReflectionArray[3];					var reflectBMD = new BitmapData(pScreenW,reflectHeight,true);					pRect = new Rectangle(0,reflectY1,pScreenW,reflectHeight);					reflectBMD.copyPixels(gDestinBMD1,pRect,pPnt,null,null,true);					var matrix:Matrix = new Matrix(1,0,0,-1,0,reflectHeight);					matrix.translate(0,reflectY3);					var ct:ColorTransform = new ColorTransform  ;					ct.alphaMultiplier = vAlpha;					reflectBMD.colorTransform(reflectBMD.rect,ct);					gDestinBMD1.draw(reflectBMD,matrix,null,null,null,true);				}				//draw foreground layer;				lx = Math.round((pScrollX * 2));				ly = Math.round((pScrollY * .5));				pRect = new Rectangle(lx,ly,pScreenW + lx,pScreenH + ly);				gDestinBMD1.copyPixels(gSourceBMD4,pRect,pPnt,null,null,true);				//draw vignette layer;				pRect = new Rectangle(0,0,pScreenW,pScreenH);				gDestinBMD1.copyPixels(gVignetteBMD,pRect,pPnt,null,null,true);				blitChatBubbles();			}		}		//;		private function blitAllAvatars(front:Boolean):void {			for (i in pRoot.pAvatarsListObj) {				var ava:Object = pRoot.pAvatarsListObj[i];				ava.blit(front);			}		}		//		private function blitChatBubbles():void {			for (i in pRoot.pAvatarsListObj) {				var ava:Object = pRoot.pAvatarsListObj[i];				ava.blitChatBubble();				ava.blitLable();			}		}		//		public function blitSprite(bmd:BitmapData,rect:Rectangle,pnt1:Point):Boolean {			if (! bmd || ! gDestinBMD1) {				return;			}			var pnt = new Point(pnt1.x - Math.round(pScrollX),pnt1.y - Math.round(pScrollY));			var onScreen:Boolean = bmdOnscreen(bmd,pnt);			if (onScreen) {				if (pVectorScene) {					gDestinBMD2.copyPixels(bmd,rect,pnt,null,null,true);				} else {					gDestinBMD1.copyPixels(bmd,rect,pnt,null,null,true);				}			}			pnt = null;			rect = null;			return onScreen;		}		//		public function blitStaticSprite(bmd:BitmapData,rect:Rectangle,pnt1:Point):Boolean {			if (! bmd || ! gDestinBMD1) {				return;			}			gDestinBMD1.copyPixels(bmd,rect,pnt1,null,null,true);			pnt = null;			rect = null;		}		//		private function bmdOnscreen(bmd,pnt):Boolean {			var x1 = pnt.x;			var y1 = pnt.y;			var x2 = x1 + bmd.width;			var y2 = y1 + bmd.height;			if (pScreenRect.containsPoint(new Point(x1,y1))) {				return true;			}			if (pScreenRect.containsPoint(new Point(x2,y1))) {				return true;			}			if (pScreenRect.containsPoint(new Point(x1,y2))) {				return true;			}			if (pScreenRect.containsPoint(new Point(x2,y2))) {				return true;			}			return false;		}		//		public function pointOnScreen(lx:int,ly:int):Boolean {			var pnt = new Point((lx - Math.round(pScrollX)),(ly - Math.round(pScrollY)));			var onScreen:Boolean = pScreenRect.containsPoint(pnt);			return onScreen;		}		//		public function blitToSource(bmd:BitmapData,rect:Rectangle,pnt:Point):void {			if (bmd) {				gSourceBMD1.copyPixels(bmd,rect,pnt,null,null,true);			}		}		//------------------------------------------------------------------------------------------------------------------------;		//------------------------------------------------------------------------------------------------------------------------;		// Collision map and physics shared functions		//------------------------------------------------------------------------------------------------------------------------		//------------------------------------------------------------------------------------------------------------------------		//find an y above the given x,y that is not colliding with the landscape, raises avatar to that level so it rests exactly above the ground		public function findAltitude(x1:int,y1:int):int {			for (var i = 1; i < 40; i++) {				var y2:int = y1 - i;				var collide:uint = gCollisionBMD.getPixel32(x1,y2);				if ((collide == 0)) {					return y2;				}			}			return -1;		}		//Find any y below a given y, that is not colliding. Used to keep head of hero from going up through ground		public function findCeiling(x1:int,y1:int):int {			for (var i = 1; i < 40; i++) {				var y2:int = y1 + i;				var collide:uint = gCollisionBMD.getPixel32(x1,y2);				if ((collide == 0)) {					return y2;				}			}			return -1;		}		//------------------------------------------------------------------------------------------------------------------------		//------------------------------------------------------------------------------------------------------------------------		// mousedown		//------------------------------------------------------------------------------------------------------------------------		//------------------------------------------------------------------------------------------------------------------------		private function mousedown(evt:MouseEvent):void {			var lx1:int = pRoot.mouseX;			var ly1:int = pRoot.mouseY;			var lx2:int = lx1 + pScrollX;			var ly2:int = ly1 + pScrollY;			var ava:Object = checkAvatarRoll(lx2,ly2,20);			if (ava) {				var id:int = ava.pId;				var nme:String = ava.pName;				if (pRoot.gModPanelObj) {					pRoot.gModPanelObj.setTargetId(id,nme);				}				if (! pAvatarPopupActive) {					openAvatarPopup(nme, lx1, ly1);				}			}		}		//		private function checkAvatarRoll(lx1:int,ly1:int, xTolerance:int):Object {			for (i in pRoot.pAvatarsListObj) {				var ava:Object = pRoot.pAvatarsListObj[i];				var lx2:int = ava.x1;				var distx:int = Math.abs((lx2 - lx1));				if ((distx < xTolerance)) {					var ly2:int = ava.y1 - 30;					var disty:int = Math.abs((ly2 - ly1));					if ((disty < 40)) {						return ava;						break;					}				}			}			return null;		}		//		private function checkAvatarRollOut():void {			if (pAvatarPopupActive) {				var lx1:int = pRoot.mouseX;				var ly1:int = pRoot.mouseY;				var lx2:int = lx1 + pScrollX;				var ly2:int = ly1 + pScrollY;				var ava:Object = checkAvatarRoll(lx2,ly2, 140);				if (! ava) {					closeAvatarPopup();				}			}		}		//------------------------------------------------------------------------------------------------------------------------		//------------------------------------------------------------------------------------------------------------------------		//Avatar popup interface		//------------------------------------------------------------------------------------------------------------------------		//------------------------------------------------------------------------------------------------------------------------		private function createAvatarPopup():void {			pAvatarPopup = new avatarPopup  ;			pRoot.addChild(pAvatarPopup);			closeAvatarPopup();		}		//		private function openAvatarPopup(nme:String, lx:int, ly:int):void {			pAvatarPopup.userName.text = nme;			pAvatarPopup.x = lx;			pAvatarPopup.y = ly;			pAvatarPopup.visible = true;			pAvatarPopupActive = true;		}		//		public function closeAvatarPopup():void {			pAvatarPopup.userName.text = "";			pAvatarPopup.visible = false;			pAvatarPopupActive = false;		}		//------------------------------------------------------------------------------------------------------------------------		//------------------------------------------------------------------------------------------------------------------------		// destroy after use		//------------------------------------------------------------------------------------------------------------------------		//------------------------------------------------------------------------------------------------------------------------		public function deleteMe():void {			traceOut("deleteMe");			for (var i = 0; i < pL3Interactive.numChildren; i++) {				var mc:Object = pL3Interactive.getChildAt(i);				if ("deleteMe" in mc) {					mc.deleteMe();				}			}			var obj:Object = null;			this.removeEventListener(Event.ENTER_FRAME,enterframe);			if (pRoot != null)				pRoot.stage.removeEventListener(MouseEvent.MOUSE_DOWN,mousedown);			pReadyState = -1;			pRoot = null;			pLoader = null;			pSwfObj = null;			pBlurFilter = null;			pClrTrans = null;			gSourceBMD1 = null;			gSourceBMD2 = null;			gSourceBMD3 = null;			gCollisionBMD = null;			gVignetteBMD = null;			gDestinBMD1 = null;			gDestinBM1 = null;			pSceneAttributes = null;			pReflection = [];		}		//------------------------------------------------------------------------------------------------------------------------		//------------------------------------------------------------------------------------------------------------------------		// tracing		//------------------------------------------------------------------------------------------------------------------------		//------------------------------------------------------------------------------------------------------------------------		private function traceOut(txt1) {			var txt2:String = "sceneSideScroll: " + txt1;			trace(txt2);		}		//		private function traceObject(obj):void {			trace("-------------");			trace("sceneSideScroll: tracing object contents:");			for (var i in obj) {				var txt = i + ":  " + obj[i];				trace(txt);			}			trace("-------------");		}		//	}}//