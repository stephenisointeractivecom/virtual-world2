package scripts.game{	import flash.display.*;	import flash.display.MovieClip;	import flash.events.*;	import flash.display.Stage;	import flash.geom.Rectangle;	import flash.net.URLRequest;	import flash.net.URLLoader;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.ColorTransform;	import fl.motion.Color;	import flash.utils.getQualifiedClassName;	import flash.media.Sound;	import flash.filters.*;	import scripts.game.particles.runDust;	import scripts.game.particles.guestDust;	import com.smartfoxserver.v2.entities.data.SFSObject;	//	public class avatarBase extends MovieClip {		public var pRoot:Object = null;		private var pStage:Object = null;		public var pRoomObj:Object = null;		private var pAction:int = 0;		private var pLoadNum:int = 0;		private var gLoader:Loader = new Loader  ;		//user variables		private var pAvatarColors:SFSObject = null;		private var pAvatarItems:SFSObject = null;		//spritesheet stuff		public var pName:String = "";		private var pScale:Number = 1;		private var pIsMe:Boolean = false;		private var pIsGuest:Boolean = false;		public var pId:int = 0;		//states		private var pClosetAvatar:Boolean = false;		private var pType:int = 0;		private var pState:int = 0;		private var pCycle1:int = 0;		//controls		private var rightPress:Boolean = false;		private var leftPress:Boolean = false;		private var upPress:Boolean = false;		private var downPress:Boolean = false;		private var aPress:Boolean = false;		private var sPress:Boolean = false;		private var dPress:Boolean = false;		private var pJumping:Boolean = false;		private var pFlip:int = 1;		//movement		private var pSpawnX:int = 0;		private var pSpawnY:int = 0;		private var x0:Number = 0;		private var y0:Number = 0;		public var x1:Number = 0;		public var y1:Number = 0;		private var x2:Number = 0;		private var y2:Number = 0;		public var dx:Number = 0;		public var dy:Number = 0;		private var xLim:int = 800;		private var yLim:int = 600;		private var pScreenW:int = 800;		private var pScreenH:int = 600;		private var xScrLim:int = 800;		private var yScrLim:int = 600;		private var pBounce:Number = .55;		private var pGravity:Number = 1;		private var pDrag_x:Number = .97;		private var pJump_dy:int = -15;		private var pColliding:int = 0;		private var pFeetElevation:int = 3;		private var pBounceX:Number = .75;		private var pBounceY:Number = .25;		private var pLim_dx:int = 10;		private var pLim_dy:int = 30;		private var pHealth:int = 100;		//recording motion data		private var pMdHasMotion:Boolean = false;		private var pMdCycle:int = 0;		private var pMdSegSize:int = 30;		private var pMotionData:Array = [];		private var pMd:Array = [];		private var pSynchAccuracy:int = 10;		private var pLocVarsCycle:int = 0;		//actions		public var pStateB:int = 1;		private var pFrm:int = 1;		private var pIdleStart:int = 1;		private var pIdleEnd:int = 1;		private var pRunStart:int = 1;		private var pRunEnd:int = 1;		private var pJumpStart:int = 1;		private var pJumpEnd:int = 1;		private var pWaveStart:int = 1;		private var pWaveEnd:int = 1;		private var pFrmDir:int = 1;		private var pLoopAnim:Boolean = true;		//chatting, lables  and bubbles		private var pBubbleActive:Boolean = false;		private var pBubbleCycle:int = 0;		private var pBubbleBase:Object;		private var pBubbleBMD:BitmapData = new BitmapData(150,75,true,0x00000000);		private var pBubbleRect:Rectangle = new Rectangle  ;		private var pBubbleClr:uint = 0xFF3300;		private var pBubbleOffset_y:int = 0;		private var pBubbleClrTrans:ColorTransform;		private var pBubbleColorArray:Array = [0xFC0519,0xFC05B6,0xBA05FC,0x2605FC,0x0595FC,0x05FCFC,0x05FC78,0x22FC05,0xCEFC05,0xFCCE05];		private var pSkinColorArray:Array = [0xFBD9DA,0xD8A8A9,0xB16A57,0x703F3C,0x350D00,0xFCE5CD,0xD4B591,0xB57C3D,0x7C551D,0x503208,0xE6DFC9,0xCFC5A3,0x9B845A,0x655433,0x47331F,0xFBEEE1,0xD3C2B5,0xD1A382,0x8E694E,0x543C2B,0xDCE6F0];		private var pHairColorArray:Array = [0x000001,0x433A53,0x5E4C43,0xD7CAC4,0xFFFFFF,0x360D0E,0x630710,0x990000,0xFF0000,0xFF6100,0xFFA536,0xA44E18,0x855943,0x937568,0xB99789,0xD6A851,0xB19E78,0xFFD78B,0xFFF1BA,0xFDEEDA,0xDCE6F0];		private var pLableBMD:BitmapData = new BitmapData(140,20,true,0x00000000);		private var pLableRect:Rectangle = new Rectangle  ;		//blitting		private var pCacheSwfBitmaps:Boolean = true;		private var pCacheSwfDone:Boolean = false;		private var swfFrames:int = 0;		private var pSheetArray:Array = [];		private var pOnScreen:Boolean = false;		private var pAvatarFront:Boolean = false;		public var pWidth:int = 0;		public var pHeight:int = 0;		private var pRegX:int = 0;		private var pRegY:int = 0;		private var pBlitPnt:Point = new Point(0,0);		private var pFrames:int = 0;		private var pBMD:BitmapData = null;		private var pRect:Rectangle = null;		private var pBlitSpritesEffects:Array = [];		//claim point effect		private var pDpSheet:Array = [];		private var pDpBMD:BitmapData = null;		private var pDpRect:Rectangle = null;		private var pDpType:int = 1;		private var pDpCycle1:int = -1;		private var pDpCycle2:int = -1;		private var pDpFrm1:int = 0;		private var pDpFrm2:int = 0;		//avatar appearance		public function avatarBase():void {		}		//		public function init(id:int, vType:int,vRoot:Object,vStage:Object,vRoomObj:Object, vName:String, isMe:Boolean, vIsGuest:Boolean, lx:int,ly:int,vScale:Number, avatarColors:SFSObject, avatarItems:SFSObject):void {			//traceOut(("-------------------------------------> init = " + [vType,vRoot,vStage,vRoomObj,isMe,lx,ly,vScale]));			pId = id;			pType = vType;			pRoot = vRoot;			pStage = vStage;			pRoomObj = vRoomObj;			pName = vName;			pIsMe = isMe;			pIsGuest = vIsGuest;			pScale = vScale;			pAvatarColors = avatarColors;			pAvatarItems = avatarItems;			pRoot.addChild(this);			setLableFrames();			this.scaleX = vScale;			this.scaleY = vScale;			if (this.sizeFrame) {				this.sizeFrame.alpha = 0;				this.regPoint.alpha = 0;			}			switch (pType) {				case 1 :					initClosetAvatar(lx,ly,vScale);					break;				case 2 :					initSidescrollAvatar(lx,ly,vScale);					break;			}		}		//		private function setLableFrames():void {			pIdleStart = getFrameByLabel("idle_start");			pIdleEnd = getFrameByLabel("idle_end");			pRunStart = getFrameByLabel("run_start");			pRunEnd = getFrameByLabel("run_end");			pJumpStart = getFrameByLabel("jump_start");			pJumpEnd = getFrameByLabel("jump_end") - 1;			pWaveStart = getFrameByLabel("wave_start");			pWaveEnd = getFrameByLabel("wave_end");			swfFrames = pJumpEnd;		}		//Avatar is placed in the closet		private function initClosetAvatar(lx:int,ly:int,vScale:Number):void {			traceOut("initClosetAvatar");			pClosetAvatar = true;			this.x = lx;			this.y = ly;			this.gotoAndPlay("closetIdleA");			if (pIsGuest) {				buildGuestAvatar();			} else {				buildAvatar();			}		}		//Avatar enters a sidescroll scene		private function initSidescrollAvatar(lx:int,ly:int,vScale:Number):void {			pClosetAvatar = false;			pBubbleBase = new bubbleBase  ;			pGravity = pRoomObj.pSceneAttributes.pGravity;			pLim_dx = pRoomObj.pSceneAttributes.pAvatarLim_dx;			pLim_dy = pRoomObj.pSceneAttributes.pAvatarLim_dy;			pAvatarFront = pRoomObj.pSceneAttributes.pAvatarFront;			pState = 1;			pBlitPnt.x = lx;			pBlitPnt.y = ly;			x0 = lx;			y0 = ly;			x1 = lx;			y1 = ly;			x2 = lx;			y2 = ly;			pDpSheet = pRoot.pSpriteSheets.pDisplayPoint;			setChatBubbleColor();			createNameLable();			if (pIsGuest) {				buildGuestAvatar();			} else {				buildAvatar();			}			this.visible = false;		}		//		private function doSilhouetteClrEffect(mc:Object):void {			if (pClosetAvatar == false && pRoomObj.pSilhouetteClr !=0) {				if (mc) {					var pSilhouetteClr = pRoomObj.pSceneAttributes.pAvatarSilhouetteClr;					var tintPercent:Number = (pRoomObj.pAvaSilClrAmount/100);					var tintColor:Color = new Color();					tintColor.setTint(pSilhouetteClr, tintPercent);					mc.transform.colorTransform = tintColor;				}			}		}		//sent from closet, start with default values then go from there.		private function buildGuestAvatar():void {			changeClothing("hair",0);			changeClothing("shirt",0);			changeClothing("pants",0);			changeClothing("shoes",0);			changeAvatarTint("skin", 21);			changeAvatarTint("hair", 21);			var blur:BlurFilter = new BlurFilter();			blur.quality = 3;			blur.blurX = 5;			blur.blurY = 5;			this.filters = [blur];			loadClothingDone();		}		//		private function buildDefaultAvatar():void {			changeClothing("hair",1);			changeClothing("shirt",1);			changeClothing("pants",1);			changeClothing("shoes",1);			changeAvatarTint("skin", 3);			loadClothingDone();		}		//sent from main, set a specific avatar configuration, either the hero or an enemy		public function buildAvatar():void {			if (!pAvatarItems.containsKey('1')){				buildDefaultAvatar();				return;			}			changeClothing("hair", pAvatarColors.getInt('HairStyle'));			changeClothing('shirt', pAvatarItems.getUtfString('1').substr(6));			changeClothing("pants", pAvatarItems.getUtfString('2').substr(6));			changeClothing("shoes", pAvatarItems.getUtfString('3').substr(6));			changeAvatarTint("skin", pAvatarColors.getUtfString('AvatarColor'));			changeAvatarTint('hair', pAvatarColors.getUtfString('HairColor'));			changeAvatarTintB('shirt', pAvatarColors.getUtfString('TopColor'));			changeAvatarTintB('pants', pAvatarColors.getUtfString('BottomColor'));			changeAvatarTintB('shoe', pAvatarColors.getUtfString('ShoeColor'));			loadClothingDone();		}		//		public function changeClothing(vtype:String,vNum:int):void {			traceOut(("changeClothing = " + [vtype,vNum]));			var clothArray:Array = [];			var target1:Object = null;			var target2:Object = null;			var target3:Object = null;			var target4:Object = null;			var target5:Object = null;			var target6:Object = null;			var nme:String = "";			switch (vtype) {				case "hair" :					pRoot.pHeroClothing.pHair = vNum;					nme = pRoot.pArrayHair[vNum];					loadClothingItem((nme + "_1"), this.head.hair.obj);					loadClothingItem((nme + "_1"),  this.head.hair.clr);					loadClothingItem((nme + "_2"), this.hair2.obj);					loadClothingItem((nme + "_2"),  this.hair2.clr);					loadClothingItem((nme + "_3"), this.hair3.obj);					loadClothingItem((nme + "_3"),  this.hair3.clr);					break;				case "shirt" :					pRoot.pHeroClothing.pShirt = vNum;					nme = pRoot.pArrayShirt[vNum];					loadClothingItem((nme+"_1"), this.shirt_1.obj);					loadClothingItem((nme+"_2"), this.shirt_2.obj);					loadClothingItem((nme+"_3"), this.shirt_3.obj);					loadClothingItem((nme+"_4"), this.shirt_4.obj);					loadClothingItem((nme+"_5"), this.shirt_5.obj);					loadClothingItem((nme+"_6"), this.skirt.obj);					break;				case "pants" :					pRoot.pHeroClothing.pPants = vNum;					nme = pRoot.pArrayPants[vNum];					loadClothingItem((nme+"_1"), this.pants_1.obj);					loadClothingItem((nme+"_2"), this.pants_2.obj);					loadClothingItem((nme+"_3"), this.pants_3.obj);					loadClothingItem((nme+"_4"), this.pants_4.obj);					loadClothingItem((nme+"_5"), this.pants_5.obj);					break;				case "shoes" :					pRoot.pHeroClothing.pShoes = vNum;					nme = pRoot.pArrayShoes[vNum];					loadClothingItem((nme+"_1"), this.shoe_L.obj);					loadClothingItem((nme+"_2"), this.shoe_R.obj);					break;			}			doSilhouetteClrEffect(target1);			doSilhouetteClrEffect(target2);		}		//		public function loadClothingItem(nme:String,target1:Object):void {			//traceOut ("load clothing item = " + [pRoot, pRoot.pClothingHolder, nme, target1]);			for (var i = 0; i < target1.numChildren + 1; i++) {				target1.removeChildAt(0);			}			var cl2:Class = pRoot.pClothingHolder.applicationDomain.getDefinition(nme) as Class;			if (cl2) {				var obj2:Object = new cl2  ;				target1.addChild(obj2);			}		}		//		public function changeAvatarTint(vType:String, clrNum:uint):void {			clr = null;			switch (vType) {				case "skin" :					clr = pSkinColorArray[clrNum - 1];					break;				case "hair" :					clr = pHairColorArray[clrNum - 1];					break;			}			if (clr) {				changeAvatarTintB(vType, clr);			}		}		public function changeAvatarTintB(vType:String, clr:String):void {			switch (vType) {				case "hair" :					changeAvatarTintC(this.head.hair.clr, clr);					changeAvatarTintC(this.hair2.clr, clr);					changeAvatarTintC(this.hair3.clr, clr);					break;				case "skin" :					changeAvatarTintC(this.head.face.clr, clr);					changeAvatarTintC(this.arm_R_1.clr, clr);					changeAvatarTintC(this.arm_R_2.clr, clr);					changeAvatarTintC(this.arm_L_1.clr, clr);					changeAvatarTintC(this.arm_L_2.clr, clr);					changeAvatarTintC(this.leg_L_1.clr, clr);					changeAvatarTintC(this.leg_L_2.clr, clr);					changeAvatarTintC(this.leg_R_1.clr, clr);					changeAvatarTintC(this.leg_R_2.clr, clr);					changeAvatarTintC(this.torso.clr, clr);					changeAvatarTintC(this.neck.clr, clr);					changeAvatarTintC(this.neck.clr, clr);					break;				case "shirt" :					changeAvatarTintC(this.shirt_1.obj.getChildAt(0).clr, clr);					changeAvatarTintC(this.shirt_2.obj.getChildAt(0).clr, clr);					changeAvatarTintC(this.shirt_3.obj.getChildAt(0).clr, clr);					changeAvatarTintC(this.shirt_4.obj.getChildAt(0).clr, clr);					changeAvatarTintC(this.shirt_5.obj.getChildAt(0).clr, clr);					changeAvatarTintC(this.skirt.obj.getChildAt(0).clr, clr);					break;				case "pants" :					changeAvatarTintC(this.pants_1.obj.getChildAt(0).clr, clr);					changeAvatarTintC(this.pants_2.obj.getChildAt(0).clr, clr);					changeAvatarTintC(this.pants_3.obj.getChildAt(0).clr, clr);					changeAvatarTintC(this.pants_4.obj.getChildAt(0).clr, clr);					changeAvatarTintC(this.pants_5.obj.getChildAt(0).clr, clr);					break;				case "shoe" :					changeAvatarTintC(this.shoe_L.obj.getChildAt(0).clr, clr);					changeAvatarTintC(this.shoe_R.obj.getChildAt(0).clr, clr);					break;			}		}		//		public function changeAvatarTintC(vTarget:Object, clr:String):void {			if (vTarget) {				var ct:ColorTransform = vTarget.transform.colorTransform;				ct.color = clr;				vTarget.transform.colorTransform = ct;			}		}		//-------------------------------------------------------		//-------------------------------------------------------		// blitting stuff		//-------------------------------------------------------		//-------------------------------------------------------		private function loadClothingDone():void {			traceOut(" loadClothingDone");			pWidth = this.width;			pHeight = this.height;			pBubbleOffset_y = (pHeight * pScale) - 20;			pRect = new Rectangle(0,0,pWidth,pHeight);			pRegX = this.regPoint.x * pScale;			pRegY = this.regPoint.y * pScale;			createGuestDust();			initBlitCache();			avatarReady();		}		//		private function avatarReady():void {			traceOut("avatarReady");			pStateB = -1;			if (pIsMe) {				pStage.addEventListener(KeyboardEvent.KEY_DOWN,keydown);				pStage.addEventListener(KeyboardEvent.KEY_UP,keyup);				pState = 3;			} else {				pState = 9;				x2 = x1 + 10;			}			startJump();		}		//-------------------------------------------------------		//-------------------------------------------------------		// Actions		//-------------------------------------------------------		//-------------------------------------------------------		public function enterframe():void {			cacheSWFBitmaps();			switch (pState) {				case 0 :					//initializing					break;				case 1 :					//waiting for clothing to load();					break;				case 3 :					//IsMe = true, create motion and send to other players					adjustFlipA();					applyGravity();					adjustFrame();					moveIt();					recordWalkData();					checkAvatarFront();					blitAddPoint();					waitToSendLocVars();					break;				case 7 :					//isMe = true. Character is not controllable while using the conversation engine. Call NPCconvoStart() or NPCconvoEnd();					applyGravity();					adjustFrame();					recordWalkData();					moveItC();					waitToSendLocVars();					NPCconvo();				case 9 :					//IsMe = false, replay motion from other player					applyGravity();					adjustFrame();					replayWalkData();					moveItC();					checkAvatarFront();					break;			}		}		//-------------------------------------------------------		//-------------------------------------------------------		// Keydown, set key states		//-------------------------------------------------------		//-------------------------------------------------------		public function keydown(e):void {			var key = e.keyCode;			switch (key) {				case 32 :					break;				case 37 :					leftPress = true;					break;				case 39 :					rightPress = true;					break;				case 38 :					jump();					break;				case 40 :					downPress = true;					break;			}			if (! pRoot.pInterface.visible) {				switch (key) {					case 65 :						aPress = true;						break;					case 83 :						sPress = true;						break;					case 68 :						dPress = true;						break;				}			}		}		//		public function keyup(e):void {			var key = e.keyCode;			//trace (key);			switch (key) {				case 9 :					//tab					pRoot.toggleSceneInterface();					break;				case 16 :					//shift					pRoot.toggleLables();					break;				case 13 :					//Return					pRoot.sendChat();					break;				case 32 :					break;				case 37 :					leftPress = false;					break;				case 39 :					rightPress = false;					break;				case 38 :					upPress = false;					break;				case 40 :					downPress = false;					break;				case 80 :					//p					if (aPress) {						pRoot.toggleModPanel();					}					break;			}			if (! pRoot.pInterface.visible) {				switch (key) {					case 65 :						//a						break;					case 83 :						//s						break;					case 68 :						//d						dPress = false;						break;					case 86 :						//v						break;					case 69 :						//e						break;					case 87 :						//w						break;				}			}		}		//		public function clearKeys():void {			leftPress = false;			rightPress = false;			upPress = false;			aPress = false;			sPress = false;			dPress = false;		}		//-------------------------------------------------------		//-------------------------------------------------------		// Move hero around based on keyboard inputs		//-------------------------------------------------------		//-------------------------------------------------------		private function moveIt():void {			if (! pJumping) {				if (leftPress) {					dx = dx - .25;				}				if (rightPress) {					dx = dx + .25;				}				//drag				if (! leftPress && ! rightPress) {					dx = dx * pDrag_x;				}				dx = dx * pDrag_x;			}			//move			moveItC();			pRoomObj.scrollMap(x1, y1);		}		//;		private function moveItC():void {			if (Math.abs(dx) > pLim_dx) {				dx = pLim_dx * (Math.abs(dx)/dx);			}			if (dy <  pJump_dy) {				dy = pJump_dy;			}			if (dy  > Math.abs(pJump_dy)) {				dy = Math.abs(pJump_dy);			}			x0 = x1;			y0 = y1;			x1 = x1 + dx;			y1 = y1 + dy;			checkCollide();			if (pJumping) {				startJump();			} else {				endJump();			}			pBlitPnt.x = (Math.floor(x1)) - pRegX;			pBlitPnt.y = (Math.floor(y1)) - pRegY - pFeetElevation;			createRunDust();		}		//-------------------------------------------------------		//-------------------------------------------------------		//non hero, (isMe = false) replay motion by heading towards a target x2,y2		//-------------------------------------------------------		//-------------------------------------------------------		private function replayWalkData():void {			if (pIsMe) {				return;			}			if (pJumping) {				return;			}			if (x1==x2 && y1 ==y2) {				return;			}			var dirX:int = 1;			if (x2 < x1) {				dirX = -1;			}			var diffX = (x2 - x1);			var diffY = (y2 - y1);			if ((Math.abs(diffX)) >  Math.abs(dx *2)) {				dx = dx + .25 * dirX;				adjustFlipB();			} else {				dx = dx * .5;				if ((Math.abs(diffX))< 10) {					x2 = x1;					y2 = y1;					startIdle();				}			}		}		//-------------------------------------------------------		//-------------------------------------------------------		//Move the avatar by changing x1, y1 and blit		//-------------------------------------------------------		//-------------------------------------------------------		private function adjustFrame():void {			switch (pStateB) {				case 1 :					idling();					break;				case 2 :					running();					break;				case 3 :					jumping();					break;			}		}		//		private function startIdle():void {			if (pStateB !=1) {				//traceOut("startIdle = " + pIdleStart);				pStateB = 1;				pFrm = pIdleStart + 2;			}		}		//		private function idling():void {			pFrm = pFrm + pFrmDir;			if (pFrm == pIdleEnd-1) {				pFrmDir = -1;			}			if (pFrm < pIdleStart+1) {				pFrmDir = 1;			}			if (Math.abs(dx) > 2) {				startRun();			}		}		//		private function startRun():void {			if (pStateB !=2) {				//traceOut("startRun");				pStateB = 2;				pFrm = pRunStart;			}		}		//		private function running():void {			pFrm++;			if (pFrm == pRunEnd) {				pFrm = pRunStart;			}			if (pFrm == 8 || pFrm ==15) {				doFootfallSound();			}			if (Math.abs(dx) < .5) {				startIdle();			}		}		//		private function doFootfallSound():void {			var r:int = 1 + pRoot.rand() * 6;			var snd:Sound = null;			switch (r) {				case 1 :					snd = new footfall_1  ;					break;				case 2 :					snd = new footfall_2  ;					break;				case 3 :					snd = new footfall_3  ;					break;				case 4 :					snd = new footfall_4  ;					break;				case 5 :					snd = new footfall_5  ;					break;				case 6 :					snd = new footfall_6  ;					break;			}			if (snd) {				pRoot.playSndVolByDist(snd, x1, y1, 700, 1);			}		}		//		private function jump():void {			if (! pJumping) {				x1 = Math.floor(x1);				y1 = Math.floor(y1);				x0 = x1;				y0 = y1;				x2 = x1;				y2 = y1;				dx = (Math.round(dx*100))/100;				recordJumpData();				jumpB();			}		}		//		private function jumpB():void {			pJumping = true;			dy = pJump_dy;			startJump();		}		//		private function startJump():void {			if (pStateB !=3) {				//traceOut("startJump = " + pStateB);				pStateB = 3;				pFrm = pJumpStart + 2;			}		}		//		private function jumping():void {			pFrm = pFrm + pFrmDir;			if (pFrm > pJumpEnd) {				pFrm = pJumpEnd;				pFrmDir = -1;			}			if (pFrm < pJumpStart) {				pFrm = pJumpStart;				pFrmDir = 1;			}		}		//		private function endJump():void {			if (pJumping || pStateB == 3) {				doJumpLandSound(1);				pJumping = false;				startIdle();			}		}		//		private function doJumpLandSound(vol:Number):void {			var r:int = pRoot.rand() * 2 + 1;			var snd:Sound = null;			switch (r) {				case 0 :				case 1 :					snd = new jumpLand1  ;					break;				case 2 :					snd = new jumpLand2  ;					break;			}			if (snd) {				pRoot.playSndVolByDist(snd, x1, y1, 700, vol);			}		}		//		private function applyGravity():void {			dy = dy + pGravity;		}		//		private function NPCconvo():void {		}		//		public function NPCconvoStart():void {			freezeAvatar();		}		//		public function NPCconvoEnd():void {			unFreezeAvatar();		}		//		public function freezeAvatar():void {			pState = 7;			dx = 0;			dy = 0;			pStateB = 1;		}		//		public function unFreezeAvatar():void {			pState = 3;			pStateB = 1;		}		//-------------------------------------------------------		//-------------------------------------------------------		//isMe = true adjust flip based on cursor keys		//-------------------------------------------------------		//-------------------------------------------------------		private function adjustFlipA():void {			if (! rightPress && ! leftPress) {				return;			}			pFlip = 1;			if (rightPress) {				pFlip = 1;			}			if (leftPress) {				pFlip = -1;			}		}		//isMe = false, adjust flip based on direction avatar is travelling		private function adjustFlipB():void {			if (dx>0) {				pFlip = 1;			} else {				pFlip = -1;			}		}		//-------------------------------------------------------		//-------------------------------------------------------		// check if hero is colliding with the edges of the map or with platforms		//-------------------------------------------------------		//-------------------------------------------------------		private function checkCollide():void {			//check collision with borders of map first			if (! pRoomObj.gCollisionBMD) {				return;			}			if (x1 < 20) {				x1 = 20;				dx = Math.abs(dx) * pBounceX;				return;			}			if (y1 < 20) {				y1 = 20;				dy = 1;				return;			}			if (x1 > pRoomObj.pMapWidth -20) {				x1 = pRoomObj.pMapWidth - 20;				dx = Math.abs(dx) * pBounceX * -1;				return;			}			if (y1 > pRoomObj.pMapHeight -20) {				y1 = pRoomObj.pMapHeight - 20;				dy = Math.abs(dy) * pBounceY * -1;				return;			}			//hit test of game layer			//Test head or feet first			var collide:uint = 1;			var y3:int = y1 - pFeetElevation;			if (dy<0) {				collide = pRoomObj.gCollisionBMD.getPixel32(x1,y1);				if (collide != 0) {					var ceiling:int = pRoomObj.findCeiling(x1,y3);					if (ceiling ==-1) {						y1 = y0;					} else {						y1 = ceiling + pFeetElevation + 1;					}					dy = 0;				}			} else {				collide = pRoomObj.gCollisionBMD.getPixel32(x1,y1);				if (collide != 0) {					pJumping = false;					var altitude:int = pRoomObj.findAltitude(x1,y1);					if (altitude ==-1) {						altitude = y0;					}					dy = (altitude - y1) * .75;					y1 = altitude;					if (Math.abs(dy) < 4) {						dy = 0;					} else {						pJumping = true;						dx = dx * .75;						doJumpLandSound(Math.abs(dy)/10);					}				}			}			//trace (collide);			//check horizontal collision			var x3 = x1 + dx;			if (x3 < 20) {				x3 = 20;			}			pColliding = pRoomObj.gCollisionBMD.getPixel32(x3,y1 - 15);			if (pColliding != 0) {				var dir:int = dx / Math.abs(dx);				x1 = x0;				if (dx > 2) {					dx = dx * pBounceX * -1;				} else {					if (dx < -2) {						dx = dx * pBounceX * -1;					}				}			} else {				checkPlatformCollide();			}		}		//		private function checkPlatformCollide():void {		}		//-------------------------------------------------------		//-------------------------------------------------------		// record position roation and currentframe for transmission and playback		//-------------------------------------------------------		//-------------------------------------------------------		private function recordWalkData():void {			pMdCycle++;			if (pMdCycle > pMdSegSize) {				switch (pStateB) {					case 1 :					case 2 :						if (MdIsDifferent(x2,y2)) {							sendMotionData(1, Math.floor(x1), Math.floor(y1), dx, dy);							x2 = x1;							y2 = y1;						}						break;				}			}		}		//only send or replay motion if the difference is great enough to justify sending the data.		private function MdIsDifferent(lx2:int, ly2:int):Boolean {			var diffx = Math.abs(lx2 - x1);			var diffy = Math.abs(ly2 - y1);			if (diffx > pSynchAccuracy || diffy > pSynchAccuracy) {				return (true);			} else {				return (false);			}		}		//		private function recordJumpData():void {			if (pIsMe) {				pMotionData = [];				sendMotionData(2, x1, y1, dx, dy);			}		}		//		private function sendMotionData(vState:int, lx:int, ly:int, dx:Number, dy:Number):void {			var mddx:int = Math.round(dx * 100);			var mddy:int = Math.round(dy * 100);			pMotionData.push(vState);			pMotionData.push(lx);			pMotionData.push(ly);			pMotionData.push(mddx);			pMotionData.push(mddy);			pRoot.sendArrayCommandAll("tmd", pMotionData);			pMotionData = [];			pMdCycle = 0;			pMd = [];		}		//		public function receiveMotionData(vData:Array):void {			if (pIsMe) {				return;			}			var vMDtype:int = vData[0];			switch (vMDtype) {				case 1 :					receiveWalkData(vData);					break;				case 2 :					receiveJumpData(vData);					break;			}		}		private function receiveWalkData(vData:Array):void {			//traceOut("receiveWalkData = " + vData);			var lx2 = vData[1];			var ly2 = vData[2];			var different:Boolean = MdIsDifferent(lx2,ly2);			if (different) {				x2 = lx2;				y2 = ly2;				dx = (vData[3])/100;				dy = (vData[4])/100;				startRun();			}		}		//		private function receiveJumpData(vData:Array):void {			//traceOut("receiveJumpData = " + vData);			x0 = vData[1];			y0 = vData[2];			dx = (vData[3])/100;			dy = (vData[4])/100;			x1 = x0;			x2 = x0;			y1 = y0;			y2 = y0;			jumpB();		}		//		private function waitToSendLocVars():void {			pLocVarsCycle++;			if (pLocVarsCycle > 90) {				pLocVarsCycle = 0;				pRoot.sendLocVars(x1, y1);			}		}		//-------------------------------------------------------		//-------------------------------------------------------		// blitting avatar and effects		//-------------------------------------------------------		//-------------------------------------------------------		public function blit(front:Boolean):void {			cacheSWFBitmaps();			if (pAvatarFront != front) {				return;			}			enterframe();			if (pState<3) {				return;			}			var onScreen:Boolean = pRoomObj.pointOnScreen(x1,y1);			if (onScreen) {				var bmdSet:Array = getAvatarBitmap(pFrm);				if (bmdSet) {					if (pFlip == -1) {						pOnScreen = pRoomObj.blitSprite(bmdSet[1],pRect,pBlitPnt);					} else {						pOnScreen = pRoomObj.blitSprite(bmdSet[0],pRect,pBlitPnt);					}					bmdSet = null;					blitSpriteEffects();				} else {					traceOut("missing blit frame = " + pFrm);				}			}		}		//		private function getAvatarBitmap(vFrm:int):Array {			var bmdSet:Array = null;			if (pCacheSwfBitmaps) {				bmdSet = pSheetArray[vFrm];				if (! bmdSet) {					bmdSet = pSheetArray[1];				}			} else {				this.gotoAndStop(vFrm);				bmdSet = convertSwfFrm();			}			return (bmdSet);		}		//		private function initBlitCache():void {			for (var i=0; i< (swfFrames+1); i++) {				pSheetArray.push(null);			}			pCacheSwfDone = false;		}		//		private function cacheSWFBitmaps():void {			if (! pCacheSwfBitmaps || pCacheSwfDone) {				return;			}			vFrm = this.currentFrame;			var bmdSet:Array = convertSwfFrm();			pSheetArray[vFrm] = bmdSet;			vFrm++;			this.gotoAndStop(vFrm);			if (vFrm >swfFrames) {				traceOut("cacheBitmap complete");				pCacheSwfDone = true;			}		}		//		private function convertSwfFrm():Array {			vFrm = this.currentFrame;			var bmd1:BitmapData = new BitmapData(pWidth,pHeight,true,0x00FFFFFF);			var bmd2:BitmapData = new BitmapData(pWidth,pHeight,true,0x00FFFFFF);			var vMatrix:Matrix = new Matrix  ;			vMatrix.scale(pScale,pScale);			bmd1.draw(this,vMatrix);			vMatrix = new Matrix  ;			vMatrix.scale((pScale * -1),pScale);			vMatrix.translate((pWidth),0);			bmd2.draw(this,vMatrix);			bmdSet = [bmd1,bmd2];			return (bmdSet);		}		//		private function blitSpriteEffects():void {			if (pOnScreen) {				for (var i = 0; i<pBlitSpritesEffects.length; i++) {					var sprt:Object = pBlitSpritesEffects[i];					sprt.enterframe();				}			} else {				deleteAllSpriteEffects();			}		}		//		private function deleteAllSpriteEffects():void {			for (var i = 0; i<pBlitSpritesEffects.length; i++) {				var sprt:Object = pBlitSpritesEffects[i];				sprt.deleteMe();			}		}		//-------------------------------------------------------		//-------------------------------------------------------		//sprite effects that are rendered same time as avatar		//-------------------------------------------------------		//-------------------------------------------------------		private function createGuestDust():void {			traceOut("createGuestDust");			if (pIsGuest){			for (var i = 0; i<60; i++) {				var obj:Object = new guestDust  ;				obj.init(pRoot, pRoomObj, this);				pBlitSpritesEffects.push(obj);			}			}		}		//		private function createRunDust():void {			if ((Math.abs(dx)) > 5 || (Math.abs(dy))>5) {				var obj:Object = new runDust  ;				obj.init(pRoot, pRoomObj, this, x1, y1);				pBlitSpritesEffects.push(obj);			}		}		//;		public function removeSpriteEffect(obj:Object):void {			//traceOut ("removeSpriteEffect");			var n:int = pBlitSpritesEffects.indexOf(obj);			if (n != -1) {				pBlitSpritesEffects.splice(n, 1);			}		}		//-------------------------------------------------------;		//-------------------------------------------------------;		// Chatting. create and blit chat bubbles. time the bubble's destruction.		//-------------------------------------------------------		//-------------------------------------------------------		public function takeChat(txt:String):void {			traceOut("takeChat = " + txt);			createChatBubble(txt);		}		//		private function setChatBubbleColor():void {			var L:int = pBubbleColorArray.length;			var r:int = Math.random() * L;			if (r>L-1) {				r = L - 1;			}			pBubbleClr = pBubbleColorArray[r];		}		//		private function createChatBubble(txt:String):void {			var vBubble:Object = null;			var L1:int = 1;			if (txt.length < 10) {				vBubble = new BLU0  ;			} else {				pBubbleBase.textbox.text = txt;				var txtHeight:Number = pBubbleBase.textbox.height;				pBubbleBase.textbox.height = txtHeight;				L1 = pBubbleBase.textbox.numLines;				if (L1>5) {					L1 = 5;				}				switch (L1) {					case 1 :						vBubble = new BLU1  ;						break;					case 2 :						vBubble = new BLU2  ;						break;					case 3 :						vBubble = new BLU3  ;						break;					case 4 :						vBubble = new BLU4  ;						break;					case 5 :						vBubble = new BLU5  ;						break;					case 6 :						vBubble = new BLU6  ;						break;				}			}			pBubbleClrTrans = vBubble.bubble.transform.colorTransform;			pBubbleClrTrans.color = pBubbleClr;			pBubbleClrTrans.greenMultiplier = 0.9;			pBubbleClrTrans.redMultiplier = 0.9;			pBubbleClrTrans.blueMultiplier = 0.9;			vBubble.bubble.transform.colorTransform = pBubbleClrTrans;			vBubble.textbox.text = txt;			pBubbleBMD.fillRect(pBubbleBMD.rect, 0);			pBubbleBMD.draw(vBubble);			pBubbleRect = pBubbleBMD.rect;			pBubbleActive = true;			pBubLimit = 60 + L1 * 60;			pBubbleCycle = 0;			pRoot.playSound(pRoot.pBubblePopSnd,100,1);			vBubble = null;		}		//		public function blitChatBubble():void {			if (! pBubbleActive || ! pOnScreen) {				return;			}			var vPnt:Point =  new Point ((pBlitPnt.x - 80), (pBlitPnt.y - pBubbleOffset_y));			pRoomObj.blitSprite(pBubbleBMD, pBubbleRect, vPnt);			pBubbleCycle++;			if (pBubbleCycle > pBubLimit) {				pBubbleActive = false;			}		}		//-------------------------------------------------------;		//-------------------------------------------------------;		//name lable		//-------------------------------------------------------		//-------------------------------------------------------		private function createNameLable():void {			vLable = new lableBase  ;			vLable.textbox.text = pName;			if (pIsGuest){				vLable.textbox.text = "Guest";				if (pIsMe){					vLable.textbox.text = "You";				}			}			pLableBMD.draw(vLable);			pLableRect = pLableBMD.rect;		}		//		public function blitLable():void {			if (pState == -1 || !pRoot.pAvatarLablesActive || ! pOnScreen) {				return;			}			var vPnt:Point =  new Point ((pBlitPnt.x-30), (pBlitPnt.y + pHeight + 5));			pRoomObj.blitSprite(pLableBMD, pLableRect, vPnt);		}		//-------------------------------------------------------		//-------------------------------------------------------		// avatar can switch from front of play are to behind on the fly depending on location		//-------------------------------------------------------		//-------------------------------------------------------		private function checkAvatarFront():void {			if (! pRoomObj.pAvatarLayerArray) {				return;			}			pAvatarFront = false;			var L:int = (pRoomObj.pAvatarLayerArray.length);			for (var i= 0; i<L; i++) {				var wp:Array = pRoomObj.pAvatarLayerArray[i];				var lx:int = wp[0];				if (x1 > lx) {					pAvatarFront = wp[2];				}			}		}		//-------------------------------------------------------		//-------------------------------------------------------		// spawns		//-------------------------------------------------------		//-------------------------------------------------------		public function displayAddPoint(vType):void {			//traceOut("displayAddPoint");			if (! pRoot) {				return;			}			pDpType = vType;			switch (pDpType) {				case 1 :					pDpFrm1 = 1;					pDpFrm2 = 5;					break;				case 2 :					pDpFrm1 = 6;					pDpFrm2 = 10;					break;				case 3 :					pDpFrm1 = 11;					pDpFrm2 = 15;					break;			}			pDpBMD = pDpSheet[pDpFrm1 - 1];			pDpRect = pDpBMD.rect;			pDpCycle1 = 0;			pDpCycle2 = 0;			if (pIsMe) {				pRoot.playSound(pRoot.pSpawnCaptureSnd,100,1);			}		}		//		private function blitAddPoint():void {			if (pDpCycle1 == -1) {				return;			}			pDpCycle1 = pDpCycle1 + 2;			if (pDpCycle1 > 100) {				pDpCycle1 = -1;				return;			}			pDpCycle2++;			if (pDpCycle2 > 10) {				pDpCycle2 = 0;				pDpFrm1++;				if (pDpFrm1 > pDpFrm2) {					pDpFrm1 = pDpFrm2;				}				pDpBMD = pDpSheet[pDpFrm1 - 1];			}			var vPnt:Point =  new Point ((pBlitPnt.x+15), (pBlitPnt.y-pDpCycle1));			pRoomObj.blitSprite(pDpBMD, pDpRect, vPnt);		}		//-------------------------------------------------------		//-------------------------------------------------------		// get frame number from frame lable by name, used for blitting animation and looping		//-------------------------------------------------------		//-------------------------------------------------------		private function getFrameByLabel(nme: String ):int {			var n:int = 0;			var lables = this.currentScene.labels;			for (var i:int =1; i < lables.length; ++i) {				var lable = lables[i];				if (lable.name == nme) {					n = lable.frame;				}			}			return n;		}		//-------------------------------------------------------		//-------------------------------------------------------		// remove object		//-------------------------------------------------------		//-------------------------------------------------------		public function deleteMe():void {			traceOut(" delete myself");			if (pState != -1) {				if (pIsMe && pStage) {					pStage.removeEventListener(KeyboardEvent.KEY_DOWN,keydown);					pStage.removeEventListener(KeyboardEvent.KEY_UP,keyup);				}				pState = -1;				pRoot = null;				pStage = null;				pRoomObj = null;				pSheetArray = null;				gLoader = null;				if (pBlitSpritesEffects) {					deleteAllSpriteEffects();					pBlitSpritesEffects = null;				}			}		}		//------------------------------------------------------------------------------------------------------------------------		//------------------------------------------------------------------------------------------------------------------------		// tracing		//------------------------------------------------------------------------------------------------------------------------		//------------------------------------------------------------------------------------------------------------------------		private function traceOut(txt1) {			var txt2:String = "avatar-" + pId + ": " + txt1;			trace(txt2);		}		//	}}///////